#' @describeIn getDimRed Generate a PCA from a qseaSet
#' @export
#'
getPCA <- function(qseaSet,
                   dataTable = NULL,
                   regionsToOverlap = NULL,
                   normMethod = "beta",
                   minEnrichment = 3,
                   useGroupMeans = FALSE,
                   minDensity = 0,
                   topVarNum = 1000,
                   topVarSamples = NULL,
                   center = TRUE,
                   scale = FALSE,
                   nPC = 5,
                   returnDataTable = FALSE) {

  getDimRed(qseaSet = qseaSet,
            dataTable = dataTable,
            method = "PCA",
            regionsToOverlap = regionsToOverlap,
            normMethod = normMethod,
            minEnrichment = minEnrichment,
            useGroupMeans = useGroupMeans,
            minDensity = minDensity,
            topVarNum = topVarNum,
            topVarSamples = topVarSamples,
            center = center,
            scale = scale,
            nPC = nPC,
            returnDataTable = returnDataTable)

}

#'@describeIn getDimRed Generate a UMAP from a qseaSet
#'@export
getUMAP <- function(qseaSet,
                   dataTable = NULL,
                   regionsToOverlap = NULL,
                   normMethod = "beta",
                   minEnrichment = 3,
                   useGroupMeans = FALSE,
                   minDensity = 0,
                   topVarNum = 1000,
                   topVarSamples = NULL,
                   returnDataTable = FALSE,
                   ...) {

  getDimRed(qseaSet = qseaSet,
            dataTable = dataTable,
            method = "UMAP",
            regionsToOverlap = regionsToOverlap,
            normMethod = normMethod,
            minEnrichment = minEnrichment,
            useGroupMeans = useGroupMeans,
            minDensity = minDensity,
            topVarNum = topVarNum,
            topVarSamples = topVarSamples,
            returnDataTable = returnDataTable,
            ...)

}

#' The functions getPCA() and getUMAP() are dimensionality reduction techniques with a very similar syntax
#' @param qseaSet A qseaSet object.
#' @param dataTable A data frame of normalised values for a set of windows (rows) and samples (columns), e.g. from [getDataTable()]. It must have seqnames, start and end columns. Can also be a [GenomicRanges::GRanges()] object with normalised values in the metadata columns.
#' @param method A character specifying method to use. Either "PCA" or "UMAP".
#' @param regionsToOverlap Optional. Only windows in `qseaSet` overlapping `regionsToOverlap` will be considered. A [GenomicRanges::GRanges()] object or a data frame which can be coerced into a [GenomicRanges::GRanges()] object.
#' @param normMethod What normalisation method to use. Typically a character giving name of predefined normalisation method (e.g. "beta" or "nrpm"). See [qsea::normMethod()].
#' @param minEnrichment Minimum number of reads for beta values to not give NA. Passed to [getDataTable()].
#' @param useGroupMeans Whether to average samples over the group column (i.e. combine replicates)
#' @param minDensity A minimum CpG density level to filter out windows with values lower than.
#' @param topVarNum Number of most variable windows to keep. Defaults to 1000. If value is NA, NULL, Inf or is at least as big as the available number of windows, then all available windows are used for the PCA/UMAP. Can also be a vector, in which case PCA/UMAP is performed for each component.
#' @param topVarSamples Samples to use to determine variability. Either NULL or NA (use all samples; default), a character vector of sample names or a regular expression to match sample names on. Can also be a list, in which case PCA/UMAP is performed for each list component. If `length(topVarNum) > 1`, list should be same length as `topVarNum` and each component will be matched with corresponding component of `topVarNum`.
#' @param center A logical value indicating if windows should be centred to have mean zero (for method PCA only). Default is TRUE.
#' @param scale A logical value indicating if windows should be scaled to have unit variance (for method PCA only). Default is FALSE.
#' @param nPC Number of principal components to be calculated (for method PCA only). Default is 5.
#' @param returnDataTable A logical value indicating if the table of normalised values (generated by [getDataTable()] or by processing the input `dataTable`) should be returned as part of the output. See below for details.
#' @param ... Other parameters to pass to [uwot::umap()] function.
#' @return A mesaDimRed object with the following components:
#' \item{res}{A named list where each component is a PCA or UMAP object. List names correspond to entries in the `params$topVar` component of the output.}
#' \item{samples}{Names of the samples analysed.}
#' \item{dataTable}{If `returnDataTable = TRUE`, the table of normalised values. The table will contain windows after filtering based on `regionsToOverlap` and `minDensity`, but prior to filtering based on `topVarNum`. Windows with missing values will also have been removed. The table will also include column(s) of window standard deviations, where applicable, with column name(s) corresponding to entries in the `params$topVar` component of the output.}
#' \item{params}{A list of the parameters used.}
#' \item{sampleTable}{A copy of the sampleTable from the qseaSet.}
#'
getDimRed <- function(qseaSet,
                      dataTable = NULL,
                      method = "PCA",
                      regionsToOverlap = NULL,
                      normMethod = "beta",
                      minEnrichment = 3,
                      useGroupMeans = FALSE,
                      minDensity = 0,
                      topVarNum = 1000,
                      topVarSamples = NULL,
                      center = TRUE,
                      scale = FALSE,
                      nPC = 5,
                      returnDataTable = FALSE,
                      ...) {

  if (!("qseaSet" %in% class(qseaSet))) {
    stop("Please provide a qseaSet in the first position.")
  }

  if (qseaSet %>% qsea::getSampleNames() %>% length() <= 2) {
    stop(glue::glue("Insufficient samples {qseaSet %>% qsea::getSampleNames() %>% length()} in provided qseaSet, must be at least 3."))
  }

  if (useGroupMeans) {
    groupString <- "sample group"
  } else {
    groupString <- "sample"
  }

  if (!is.null(dataTable)) {
    dataTable <- asValidGranges(dataTable)

    samples <- dataTable %>%
      tidyr::as_tibble() %>%
      dplyr::select(-tidyselect::any_of(c("seqnames", "start", "end", "width", "strand", "CpG_density"))) %>%
      colnames()

    normMethodSuffixDetected <- stringr::str_detect(samples, glue::glue("_{normMethod}$"))

    if (all(normMethodSuffixDetected)) {
      samples <- stringr::str_remove(samples, glue::glue("_{normMethod}$"))
      dataTable <- removeNormMethodSuffix(dataTable %>% tidyr::as_tibble(),
                                          normMethod) %>%
        asValidGranges()
    } else if (any(normMethodSuffixDetected)) {
      stop(glue::glue("normMethod suffix '_{normMethod}' is present for some but not all of the {groupString} column names in dataTable."))
    }

    if (useGroupMeans) {
      if (!all(samples %in% names(qsea::getSampleGroups(qseaSet)))) {
        stop(glue::glue("At least one {groupString} name in dataTable does not have a matching {groupString} name in qseaSet.
             (If there is a normMethod suffix on the {groupString} column names in dataTable, check it matches the input normMethod argument: '_{normMethod}')"))
      }
    } else {
      if (!all(samples %in% qsea::getSampleNames(qseaSet))) {
        stop(glue::glue("At least one {groupString} name in dataTable does not have a matching {groupString} name in qseaSet.
             (If there is a normMethod suffix on the {groupString} column names in dataTable, check it matches the input normMethod argument: '_{normMethod}')"))
      }
    }

    if (length(plyranges::setdiff_ranges(dataTable, getWindows(qseaSet))) > 0) {
      stop("At least one window in dataTable does not have a matching window in qseaSet.")
    }

    testSamples <- samples[1:min(5, length(samples))]
    inputValues <- dataTable[1:min(50, length(dataTable)), ]
    testValues <- getDataTable(qseaSet %>%
                                 filter(sample_name %in% testSamples) %>%
                                 filterByOverlaps(inputValues),
                               normMethod,
                               useGroupMeans = useGroupMeans) %>%
      dplyr::arrange(seqnames, start, end)

    if (!isTRUE(all.equal(testValues, inputValues %>%
                          tidyr::as_tibble() %>%
                          dplyr::select(tidyselect::all_of(colnames(testValues))) %>%
                          dplyr::arrange(seqnames, start, end)))) {
      warning("Newly-generated dataTable from qseaSet on a small subset of samples/windows does not match input dataTable.")
    }
    initialNumWindows <- length(dataTable)
  } else {

    if (useGroupMeans) {
      samples <- names(qsea::getSampleGroups(qseaSet))
    } else {
      samples <- qsea::getSampleNames(qseaSet)
    }
    initialNumWindows <- getWindows(qseaSet) %>% length()
  }

  message(glue::glue("------------------------------
                     Initial number of windows = {initialNumWindows}."))

  if (!is.null(regionsToOverlap)) {
    regionsToOverlap <- regionsToOverlap %>%
      tibble::as_tibble() %>%
      dplyr::select(tidyselect::any_of(c("seqnames", "start", "end", "CpG_density"))) %>%  # keep only minimum columns necessary
      asValidGranges()

    if (is.null(dataTable)) {
      qseaSet <- qseaSet %>%
        filterByOverlaps(regionsToOverlap = regionsToOverlap)

      numWindowsRemovedRegionOverlap <- initialNumWindows - length(getWindows(qseaSet))
      message(glue::glue("Filtered out {numWindowsRemovedRegionOverlap} windows using regionsToOverlap: {length(getRegions(qseaSet))} windows remaining."))

    } else {
      dataTable <- dataTable %>%
        plyranges::filter_by_overlaps(y = regionsToOverlap)

      numWindowsRemovedRegionOverlap <- initialNumWindows - length(dataTable)
      message(glue::glue("Filtered out {numWindowsRemovedRegionOverlap} windows using regionsToOverlap: {length(dataTable)} windows remaining."))
    }
  } else {
    numWindowsRemovedRegionOverlap <- NULL
  }

  if (is.null(dataTable)) {
    message("-----------")
    dataTable <- qseaSet %>%
      filterWindows(CpG_density >= minDensity) %>%
      getDataTable(normMethod = normMethod, useGroupMeans = useGroupMeans)
    message("-----------")

    if (minDensity > 0) {
      numWindowsRemovedMinDensity <- length(getWindows(qseaSet)) - nrow(dataTable)
      message(glue::glue("Filtered out {numWindowsRemovedMinDensity} windows with CpG_density < {minDensity}: {nrow(dataTable)} windows remaining."))
    } else {
      numWindowsRemovedMinDensity <- NULL
    }

  } else {
    currentNumWindows <- length(dataTable)
    dataTable <- dataTable %>%
      tidyr::as_tibble() %>%
      dplyr::left_join(qseaSet %>%
                         getWindows() %>%
                         tidyr::as_tibble() %>%
                         dplyr::select(seqnames, start, end, CpG_density),
                       by = dplyr::join_by(seqnames, start, end, CpG_density)) %>%
      dplyr::filter(CpG_density >= minDensity)

    if (minDensity > 0) {
      numWindowsRemovedMinDensity <- currentNumWindows - nrow(dataTable)
      message(glue::glue("Filtered out {numWindowsRemovedMinDensity} windows with CpG_density < {minDensity}: {nrow(dataTable)} windows remaining."))
    } else {
      numWindowsRemovedMinDensity <- NULL
    }

  }

  currentNumWindows <- nrow(dataTable)

  dataTable <- dataTable %>%
    tidyr::drop_na(tidyr::all_of(samples))

  numWindowsRemovedMissingVals <- currentNumWindows - nrow(dataTable)

  if (numWindowsRemovedMissingVals > 0) {
    message(glue::glue("Filtered out {numWindowsRemovedMissingVals} windows with at least one missing value: {nrow(dataTable)} windows remaining.
                       ------------------------------"))
  } else {
    message(glue::glue("No windows have missing values.
            ------------------------------"))
  }

  if (nrow(dataTable) <= 2) {
    stop(glue::glue("Insufficient windows {nrow(dataTable)} remaining after filtering! Have you filtered for poor quality samples?"))
  }

  if (is.null(topVarNum)) {
    topVarNum <- NA
  } else if (!(length(topVarNum) == 1 && is.na(topVarNum)) & !is.vector(topVarNum, mode = "numeric")) {
    stop("topVarNum should be a numeric vector (or NULL")
  }

  if (!is.list(topVarSamples)) {
    topVarSamples <- list(topVarSamples)
  }

  if (length(topVarNum) > 1 && !(length(topVarSamples) %in% c(1, length(topVarNum)))) {
    stop("If topVarSamples is a list and length(topVarNum) > 1, topVarSamples should be the same length as topVarNum.")
  }


  # replace NA with NULL
  topVarSamples <- purrr::map(topVarSamples, function(tVS) {

    if (length(tVS) == 1 && is.na(tVS)) {
      tVS <- NULL
    }

    return(tVS)
  })

  topVarSamplesInput <- topVarSamples

  topVarSamples <- purrr::map(topVarSamples, function(tVS) {

    if (!is.null(tVS)) {
      if (!is.vector(tVS, mode = "character")) {
        stop(glue::glue("topVarSamples should be NULL, a character vector of {groupString} names or a regular expression (or a list of these)."))

      } else if (length(tVS) > 1) { # character vector of sample (group) names
        notInSamples <- setdiff(tVS, samples)
        if (length(notInSamples) > 0) {
          stop(glue::glue("topVarSamples contains {groupString} names that are not in the qseaSet and/or dataTable:
                        {paste0(notInSamples, collapse = ', ')}."))
        }

      } else { # regular expression to match
        tVS <- stringr::str_subset(samples, tVS)

      }

    } else {
      tVS <- samples

    }

    return(tVS)

  })

  topVar <- tibble::tibble(topVarNum = topVarNum, topVarSamples = topVarSamples, topVarNumInput = topVarNum, topVarSamplesInput = topVarSamplesInput) %>%
    dplyr::mutate(topVarNum = ifelse(topVarNum >= nrow(dataTable), NA, topVarNum),
                  topVarSamples = ifelse(is.na(topVarNum), list(NULL), topVarSamples),
                  inputChanged = !purrr::map2_lgl(topVarNum, topVarNumInput, identical) |
                    !purrr::map2_lgl(topVarSamples, topVarSamplesInput, identical))

  if (any(topVar$topVarNumInput > nrow(dataTable), na.rm = TRUE)) {
    message(glue::glue("The following topVarNum values are larger than the number of remaining windows (= {nrow(dataTable)}): {paste0(dplyr::filter(topVar, topVarNumInput > nrow(dataTable)) %>% pull(topVarNumInput) %>% unique(), collapse = ', ')}"))

    if (any(is.na(topVar$topVarNumInput) | topVar$topVarNumInput == nrow(dataTable))) {
      message(glue::glue("These values are not used; {method} is already being done with all remaining windows."))
    } else {
      message(glue::glue("These values are not used; {method} will be done with all remaining windows instead."))
    }
  }

  topVar <- topVar %>%
    dplyr::distinct(topVarNum, topVarSamples, .keep_all = TRUE) %>%
    dplyr::group_by(topVarSamples) %>%
    dplyr::mutate(windowSdName = ifelse(!is.na(topVarNum), glue::glue("windowSd{dplyr::cur_group_id()}"), NA), .before = 1) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(windowSdName, topVarNum) %>%
    dplyr::mutate(resName = glue::glue("{method %>% stringr::str_to_lower()}{dplyr::row_number()}"), .before = 1) %>%
    dplyr::bind_rows(topVar) %>%
    dplyr::distinct(topVarNum, topVarSamples, topVarNumInput, topVarSamplesInput, .keep_all = TRUE)

  rowSds <- function(x) {
    sqrt(rowSums((x - rowMeans(x)) ^ 2) / (ncol(x) - 1))
  }

  if (any(!is.na(topVar$windowSdName))) {
    dataTable <- topVar %>%
      tidyr::drop_na(windowSdName) %>%
      dplyr::select(topVarSamples, windowSdName) %>%
      dplyr::distinct() %>%
      dplyr::mutate(topVarSamples = purrr::set_names(topVarSamples, windowSdName)) %>%
      dplyr::pull(topVarSamples) %>%
      purrr::imap(function(tVS, nm) {

        if (length(setdiff(samples, tVS)) == 0) {
          message(glue::glue("Calculating standard deviation for each window across all {length(samples)} {groupString}s:
                           {paste0(tVS, collapse = ', ')}.
                           -> column name {nm}."))
        } else {
          message(glue::glue("Calculating standard deviation for each window across {length(tVS)} of {length(samples)} {groupString}s:
                           {paste0(tVS, collapse = ', ')}.
                           -> column name {nm}."))
        }

        if (length(tVS) <= 2) {
          stop(glue::glue("Standard deviation calculated on less than 3 {groupString} names. Insufficent number of {groupString}s to calculate variance."))
        }

        dataTable <- dataTable %>%
          dplyr::mutate({{nm}} := dplyr::select(., tidyr::all_of(tVS)) %>%
                          rowSds()) %>%
          dplyr::select(seqnames, start, end, tidyr::all_of(nm))

      }) %>%
      purrr::reduce(dplyr::left_join) %>%
      dplyr::left_join(dataTable, .,
                       by = dplyr::join_by(seqnames, start, end))
  }

  res <- topVar %>%
    dplyr::group_by(windowSdName) %>%
    dplyr::group_map(.keep = TRUE, .f = function(sdGp, sdName) {

      if (!is.na(sdName$windowSdName)) {
        dataTable <- dataTable %>%
          dplyr::arrange(dplyr::desc(!!dplyr::sym(sdName$windowSdName)))
      }

      purrr::pmap(sdGp, function(resName, windowSdName, topVarNum, topVarSamples, topVarNumInput, topVarSamplesInput, inputChanged) {

        if (!is.na(windowSdName)) {
          th <- dataTable %>%
            dplyr::pull({{windowSdName}}) %>%
            dplyr::nth(topVarNum)

          dataTable <- dataTable %>%
            dplyr::filter(!!dplyr::sym(windowSdName) >= th)

          if (length(topVarSamples) == length(samples)) {

            message(glue::glue("------------------------------
                             Filtering windows based on standard deviation across all {length(topVarSamples)} {groupString}s ({windowSdName}).
                             Standard deviation threshold = {format(th, digits = 3)} resulting in {nrow(dataTable)} windows."))
          } else {
            message(glue::glue("------------------------------
                             Filtering windows based on standard deviation across {length(topVarSamples)} {groupString}s ({windowSdName}).
                             Standard deviation threshold = {format(th, digits = 3)} resulting in {nrow(dataTable)} windows."))
          }


        } else {

          message(glue::glue("------------------------------
                             No filtering of windows based on window standard deviation."))
          th <- NA
        }

        dataTable <- dataTable %>%
          dplyr::mutate(window = getWindowNames(.)) %>%
          tibble::column_to_rownames("window") %>%
          dplyr::select(tidyr::all_of(samples))

        message(glue::glue("Performing {method} with {ncol(dataTable)} {groupString}s and {nrow(dataTable)} windows
                           -> {resName}."))

        dataTable <- dataTable %>%
          t()

        if (!is.numeric(dataTable)) {
          stop("Input contains non-numeric values.")
        }

        if (any(is.na(dataTable))) {
          stop("Input contains missing values.")
        }

        if (any(!is.finite(dataTable))) {
          stop("Input contains infinite values.")
        }

        if (method == "UMAP") {

          uwotObj <- dataTable %>%
            uwot::umap(n_components = 3,
                       ...) %>%
            as.data.frame()

          colnames(uwotObj) <- paste0("UMAP",seq_along(1:ncol(uwotObj)))

          return(list(resObj =  list(x = uwotObj, windows = colnames(dataTable)), th = th))

        } else if (method == "PCA") {

          prcompObj <- dataTable %>%
            stats::prcomp(center = center, scale. = scale, rank. = nPC)

          return(list(resObj = prcompObj, th = th))

        } else {
          stop(glue::glue("Method {method} not known! Options are PCA or UMAP."))
        }

      }) %>%
        purrr::set_names(sdGp$resName)
    }) %>%
    purrr::list_flatten()

  message("------------------------------")

  th <- purrr::map(res, "th") %>%
    unlist()

  res <- purrr::map(res, "resObj")

  if (method == "UMAP") {
    windows <- purrr::map(res, "windows")
  } else if (method == "PCA") {
    windows <- purrr::map(res, ~ rownames(.x$rotation))
  }

  paramList <- list(method = method,
                    regionsToOverlap = regionsToOverlap,
                    normMethod = normMethod,
                    minEnrichment = minEnrichment,
                    useGroupMeans = useGroupMeans,
                    minDensity = minDensity,
                    topVar = topVar,
                    windowSdThreshold = th)

  if (method == "UMAP") {
    paramList <- c(paramList, ...)

    elements <- purrr::map2(res, windows, function(x,y) {
      methods::new("mesaUMAP",
          points = x$x,
          windows = y
      )
    }
    ) %>%
      rlang::set_names(nm = names(res))

  } else if (method == "PCA") {
    paramList <- c(paramList, list(center = center,
                                   scale = scale,
                                   nPC = nPC))

    elements <- purrr::map2(res, windows, function(x,y) {
      methods::new("mesaPCA",
          prcomp = x,
          windows = y
      )
    }
    ) %>%
      rlang::set_names(nm = names(res))

  }



  windowFilteringList <- list(initial = initialNumWindows,
                              notInRegionsToOverlap = numWindowsRemovedRegionOverlap,
                              belowMinDensity = numWindowsRemovedMinDensity,
                              containMissingVals = numWindowsRemovedMissingVals)

  out <- methods::new("mesaDimRed",
              samples = samples,
              sampleTable = qseaSet %>% qsea::getSampleTable(),
              params = c(paramList,windowFilteringList),
              dataTable = if (returnDataTable) { dataTable } else { data.frame() },
              res = elements
  )

  return(out)
}


getShapeScale <- function(plotData, shape, shapePalette, colourScaleType = NULL, NAshape = 7) {

  if (shape == "NULLshape") {
    my_scale_shape <- ggplot2::scale_shape_identity(na.value = NAshape)

  } else {

    nShape <- plotData %>% pull(shape) %>% setdiff(NA) %>%  unique() %>% length()

    if (is.null(shapePalette)) {
      if (!is.null(colourScaleType) && colourScaleType == "diverging") {
        if (any(is.na(plotData %>% pull(shape)))) {
          shapePalette <- c(21, 24, 22, 23)
          NAshape <- 25
        } else {
          shapePalette <- c(21, 24, 22, 23, 25)
        }
        if (nShape > length(shapePalette)) {
          stop(glue::glue("`shape` variable '{shape}' has {nShape} unique values; the maximum allowed by default when using a divergent colour scale is {length(shapePalette)} unique values."))
        }

      } else {
        shapePalette <- c(16, 4, 0, 17, 8, 9, 15, 13, 2, 18, 14, 3, 1, 5, 6, 10, 11, 12)
        if (nShape > length(shapePalette)) {
          stop(glue::glue("`shape` variable '{shape}' has {nShape} unique values; the maximum allowed by default is {length(shapePalette)} unique values."))
        }
      }

    } else if (is.numeric(shapePalette)) {
      if (nShape > length(shapePalette)) {
        stop(glue::glue("`shape` variable '{shape}' has {nShape} unique values; the `shapePalette` argument only has {length(shapePalette)} unique values."))
      }
      if (any(0:20 %in% shapePalette) & any(21:25 %in% shapePalette)) {
        stop("'shapePalette' argument can either contain integers between 0 and 20 (line or filled shapes), or between 21 and 25 (filled shapes with borders), but not both.")
      }
      if (any(21:25 %in% shapePalette)) {
        NAshape <- 25
      }

    } else if (is.character(shapePalette)) {
      shapesInput <- shapePalette
      if (shapePalette == "filled+border") {
        if (any(is.na(plotData %>% pull(shape)))) {
          shapePalette <- c(21, 24, 22, 23)
          NAshape <- 25
        } else {
          shapePalette <- c(21, 24, 22, 23, 25)
        }
      } else {
        if (shapePalette == "line-first") {
          shapePalette <- c(1, 8, 2, 0, 9, 3, 13, 6, 14, 4, 5, 10, 11, 12, 16, 17, 15, 18)
        } else if (shapePalette == "filled-first") {
          shapePalette <- c(16, 17, 15, 18, 1, 8, 2, 0, 9, 3, 13, 6, 14, 4, 5, 10, 11, 12)
        } else if (shapePalette == "mixture") {
          shapePalette <- c(16, 4, 0, 17, 8, 9, 15, 13, 2, 18, 14, 3, 1, 5, 6, 10, 11, 12)
        } else {
          stop("`shapePalette` argument can take the following character values: 'line-first', 'filled-first', 'mixture' or 'filled+border'; or can be numeric or NULL.")
        }

        if (colourScaleType == "diverging") {
          warning(glue::glue("Using the '{shapesInput}' colour scale with a divergent colour scale may lead to points around zero on the colour scale being almost invisible."))
        }
      }
      if (nShape > length(shapePalette)) {
        stop(glue::glue("`shape` variable '{shape}' has {nShape} unique values; there are only {length(shapePalette)} shapes available with argument `shapePalette` = '{shapesInput}'."))
      }
    } else {
      stop("`shapePalette` argument is not in a valid format. It can take the following character values: 'line-first', 'filled-first', 'mixture' or 'filled+border'; or can be numeric or NULL.")
    }

    if(!is.null(NAshape)) {
      if (NAshape %in% shapePalette[1:nShape] & any(is.na(plotData %>% pull(!!shape)))) {
        stop(glue::glue("NA shape value (={NAshape}) is already being used for a '{shape}' category. Values in use: {paste0(shapePalette[1:nShape], collapse = ', ')}."))
      }
    }

    my_scale_shape <- ggplot2::scale_shape_manual(values = shapePalette, na.value = NAshape)
  }

  return(my_scale_shape)

}

getGeomPoint <- function(cV, shape, my_scale_shape, pointSize, alpha) {

  filledShapes <- ifelse(my_scale_shape$scale_name == "manual" && any(my_scale_shape$palette(1) %in% 21:25),
                         TRUE, FALSE)
  
  if (filledShapes) {
    my_geom_point <- ggplot2::geom_point(ggplot2::aes(fill = !!rlang::sym(cV), shape = !!rlang::sym(shape)),
                                         colour = "black", size = pointSize, alpha = alpha)
  } else {
    my_geom_point <- ggplot2::geom_point(ggplot2::aes(colour = !!rlang::sym(cV), shape = !!rlang::sym(shape)),
                                         size = pointSize, alpha = alpha)
  }

  return(my_geom_point)

}

getColourScale <- function(plotData, cV, cols, colourScaleType, my_scale_shape, NAcolour, symDivColourScale) {

  filledShapes <- ifelse(my_scale_shape$scale_name == "manual" & any(my_scale_shape$palette(1) %in% 21:25),
                         TRUE, FALSE)

  if (is.null(cols)) {
    if (colourScaleType == "qualitative") {
      my_scale_colour <- if (filledShapes) {
        hues::scale_fill_iwanthue(na.value = NAcolour)
      } else {
        hues::scale_colour_iwanthue(na.value = NAcolour)
      }
    } else if (colourScaleType == "sequential_non_neg") {
      my_scale_colour <- if (filledShapes) {
        ggplot2::scale_fill_viridis_c(na.value = NAcolour)
      } else {
        ggplot2::scale_colour_viridis_c(na.value = NAcolour)
      }
    } else if (colourScaleType == "sequential_non_pos") {
      my_scale_colour <- if (filledShapes) {
        ggplot2::scale_fill_viridis_c(direction = -1, na.value = NAcolour)
      } else {
        ggplot2::scale_colour_viridis_c(direction = -1, na.value = NAcolour)
      }
    } else if (colourScaleType == "diverging") {
      cols <- RColorBrewer::brewer.pal(9, "RdBu") %>% rev()
      cols[5] <- "grey90"
    }

  } else {
    if (colourScaleType == "qualitative") {
      nCol <- plotData %>% pull(cV) %>% setdiff(NA) %>% unique() %>% length()
      if (nCol > length(cols)) {
        stop(glue::glue("`colour` variable '{cV}' has {nCol} unique values; the `colourPalette` argument only has {length(cols)} unique values."))
      }
      my_scale_colour <- if (filledShapes) {
        ggplot2::scale_fill_manual(values = cols, na.value = NAcolour)
      } else {
        ggplot2::scale_colour_manual(values = cols, na.value = NAcolour)
      }

    } else if (colourScaleType == "sequential_non_neg" | colourScaleType == "sequential_non_pos") {
      my_scale_colour <- if (filledShapes) {
        ggplot2::scale_fill_gradientn(colours = cols, na.value = NAcolour)
      } else {
        ggplot2::scale_colour_gradientn(colours = cols, na.value = NAcolour)
      }
    }
  }

  if (colourScaleType == "diverging") {

    cVdat <- plotData[[cV]]

    if (symDivColourScale) {
      maxCV <- max(cVdat, na.rm = TRUE)
      minCV <- min(cVdat, na.rm = TRUE)
      absMinCV <- abs(minCV)
      if (abs(minCV) < maxCV) {
        # minimum (negative) value is smaller in magnitude than the largest (positive) value; colour scale needs to be extended beyond the minimum value
        vals <- scales::rescale(c(-maxCV, 0, maxCV),
                                to = c(-(maxCV - absMinCV) / (absMinCV + maxCV), 1))
      } else {
        # minimum (negative) value is larger in magnitude than the largest (positive) value; colour scale needs to be extended beyond the maximum value
        vals <- scales::rescale(c(minCV, 0, -minCV),
                                to = c(0, 1 +  (absMinCV - maxCV) / (absMinCV + maxCV)))
      }

      my_scale_colour <- if (filledShapes) {
        ggplot2::scale_fill_gradientn(colours = cols, values = vals, na.value = NAcolour)
      } else {
        ggplot2::scale_colour_gradientn(colours = cols, values = vals, na.value = NAcolour)
      }

    } else {
      my_scale_colour <- if (filledShapes) {
        ggplot2::scale_fill_gradientn(colours = cols,
                                      values = scales::rescale(c(min(cVdat, na.rm = TRUE), 0, max(cVdat, na.rm = TRUE))),
                                      na.value = NAcolour)
      } else {
        ggplot2::scale_colour_gradientn(colours = cols,
                                        values = scales::rescale(c(min(cVdat, na.rm = TRUE), 0, max(cVdat, na.rm = TRUE))),
                                        na.value = NAcolour)
      }
    }
  }

  return(my_scale_colour)

}

#' This function takes the output of [getPCA()] and produces plots.
#' @param object The output from [getPCA()].
#' @param qseaSet The qseaSet object used to generate `object`.
#' @param components Vector of the two components to plot, or a list of vectors to make multiple plots. Default is to produce plots for PC1 vs PC2 and PC2 vs PC3 for PCA and UMAP1 vs UMAP2 for UMAP.
#' @param colour Character vector of variable names from the qseaSet sample table for setting the colour of the points (samples). Separate plots are made for each variable.
#' @param colourPalette Character vector giving the colour palette to use for the points (samples). Defaults are used if not supplied.
#' @param NAcolour Colour to use for NA values in the `colour` variable. Default is "grey50".
#' @param symDivColourScale Logical indicating if a diverging colour scale should be symmetric around zero (ignored if a diverging colour scale is not used).
#' @param shape Character giving variable name from the qseaSet sample table for setting the shape of the points (samples). Can only accept a single variable name.
#' @param shapePalette Shapes to use for the points (samples) for each category of the `shape` variable. Can be one of the following options:
#' * A numeric vector specifying the set of shapes. Can be either integers between 0 and 20 (line or filled shapes) or integers between 21 and 25 (filled shapes with a border; border colour is set to black).
#' * A character specifying which types of shapes to use (with the exact set of shapes set internally by the function). Either:
#'     * "line-first" (15 line shapes, then 4 filled shapes; max. 19 categories).
#'     * "filled-first" (4 filled shapes, then 15 line shapes; max. 19 categories).
#'     * "mixture" (mixture of line and filled shapes; max. 19 categories).
#'     * "filled+border" (max. 5 categories, or 4 if there are NAs in the `shape` variable).
#' * NULL; defaults are used which is the "mixture" set of shapes for non-diverging colour scales (or no colour scale) and "filled+border" for diverging colour scales.
#' @param NAshape Shape to use for NA values in the `shape` variable. Default is shape 7, or shape 25 if filled shapes with a border are being used.
#' @param showSampleNames Logical indicating whether to show the sample names.
#' @param pointSize Numeric value to set the size of the points. Default is 2.
#' @param alpha Numeric value between 0 and 1 to set alpha of points. Default is 1.
#' @param plotlyAnnotations Vector of columns to annotate for plotly, e.g. c("group","tissue")
#' @return A list of ggplot objects: one for each combination of `object@res`, `colour` and `components`.
#' @export
plotPCA <- function(object,
                    qseaSet = NULL,
                    components = list(c(1, 2), c(2, 3)),
                    colour = NULL,
                    colourPalette = NULL,
                    NAcolour = "grey50",
                    symDivColourScale = FALSE,
                    shape = NULL,
                    shapePalette = NULL,
                    NAshape = NULL,
                    showSampleNames = FALSE,
                    pointSize = 2,
                    alpha = 1,
                    plotlyAnnotations = "") {

  out <- plotDimRed(object = object,
             qseaSet = qseaSet,
             components = components,
             colour = {{colour}},
             colourPalette = colourPalette,
             NAcolour = NAcolour,
             symDivColourScale = symDivColourScale,
             shape = {{shape}},
             shapePalette = shapePalette,
             NAshape = NAshape,
             showSampleNames = showSampleNames,
             pointSize = pointSize,
             alpha = alpha,
             plotlyAnnotations = plotlyAnnotations)

  return(out)
}

#' This function takes the output of [getUMAP()] and produces plots.
#' @param object The output from [getUMAP()].
#' @param qseaSet The qseaSet object used to generate `object`.
#' @param components Vector of the two components to plot, or a list of vectors to make multiple plots. Default is to produce plots for PC1 vs PC2 and PC2 vs PC3 for PCA and UMAP1 vs UMAP2 for UMAP.
#' @param colour Character vector of variable names from the qseaSet sample table for setting the colour of the points (samples). Separate plots are made for each variable.
#' @param colourPalette Character vector giving the colour palette to use for the points (samples). Defaults are used if not supplied.
#' @param NAcolour Colour to use for NA values in the `colour` variable. Default is "grey50".
#' @param symDivColourScale Logical indicating if a diverging colour scale should be symmetric around zero (ignored if a diverging colour scale is not used).
#' @param shape Character giving variable name from the qseaSet sample table for setting the shape of the points (samples). Can only accept a single variable name.
#' @param shapePalette Shapes to use for the points (samples) for each category of the `shape` variable. Can be one of the following options:
#' * A numeric vector specifying the set of shapes. Can be either integers between 0 and 20 (line or filled shapes) or integers between 21 and 25 (filled shapes with a border; border colour is set to black).
#' * A character specifying which types of shapes to use (with the exact set of shapes set internally by the function). Either:
#'     * "line-first" (15 line shapes, then 4 filled shapes; max. 19 categories).
#'     * "filled-first" (4 filled shapes, then 15 line shapes; max. 19 categories).
#'     * "mixture" (mixture of line and filled shapes; max. 19 categories).
#'     * "filled+border" (max. 5 categories, or 4 if there are NAs in the `shape` variable).
#' * NULL; defaults are used which is the "mixture" set of shapes for non-diverging colour scales (or no colour scale) and "filled+border" for diverging colour scales.
#' @param NAshape Shape to use for NA values in the `shape` variable. Default is shape 7, or shape 25 if filled shapes with a border are being used.
#' @param showSampleNames Logical indicating whether to show the sample names.
#' @param pointSize Numeric value to set the size of the points. Default is 2.
#' @param alpha Numeric value between 0 and 1 to set alpha of points. Default is 1.
#' @param plotlyAnnotations Vector of columns to annotate for plotly, e.g. c("group","tissue")
#' @return A list of ggplot objects: one for each combination of `object@res`, `colour` and `components`.
#' @export
#'
plotUMAP <- function(object,
                     qseaSet = NULL,
                     components = list(c(1, 2)),
                     colour = NULL,
                     colourPalette = NULL,
                     NAcolour = "grey50",
                     symDivColourScale = FALSE,
                     shape = NULL,
                     shapePalette = NULL,
                     NAshape = NULL,
                     showSampleNames = FALSE,
                     pointSize = 2,
                     alpha = 1,
                     plotlyAnnotations = "") {

  out <- plotDimRed(object = object,
             qseaSet = qseaSet,
             components = components,
             colour = colour,
             colourPalette = colourPalette,
             NAcolour = NAcolour,
             symDivColourScale = symDivColourScale,
             shape = shape,
             shapePalette = shapePalette,
             NAshape = NAshape,
             showSampleNames = showSampleNames,
             pointSize = pointSize,
             alpha = alpha,
             plotlyAnnotations = plotlyAnnotations)

  return(out)
}

#' This function takes the output of [getPCA()] or [getUMAP()] and produces plots.
#' @param object The output from [getPCA()] or [getUMAP()].
#' @param qseaSet The qseaSet object used to generate `object`.
#' @param components Vector of the two components to plot, or a list of vectors to make multiple plots. Default is to produce plots for PC1 vs PC2 and PC2 vs PC3 for PCA and UMAP1 vs UMAP2 for UMAP.
#' @param colour Character vector of variable names from the qseaSet sample table for setting the colour of the points (samples). Separate plots are made for each variable.
#' @param colourPalette Character vector giving the colour palette to use for the points (samples). Defaults are used if not supplied.
#' @param NAcolour Colour to use for NA values in the `colour` variable. Default is "grey50".
#' @param symDivColourScale Logical indicating if a diverging colour scale should be symmetric around zero (ignored if a diverging colour scale is not used).
#' @param shape Character giving variable name from the qseaSet sample table for setting the shape of the points (samples). Can only accept a single variable name.
#' @param shapePalette Shapes to use for the points (samples) for each category of the `shape` variable. Can be one of the following options:
#' * A numeric vector specifying the set of shapes. Can be either integers between 0 and 20 (line or filled shapes) or integers between 21 and 25 (filled shapes with a border; border colour is set to black).
#' * A character specifying which types of shapes to use (with the exact set of shapes set internally by the function). Either:
#'     * "line-first" (15 line shapes, then 4 filled shapes; max. 19 categories).
#'     * "filled-first" (4 filled shapes, then 15 line shapes; max. 19 categories).
#'     * "mixture" (mixture of line and filled shapes; max. 19 categories).
#'     * "filled+border" (max. 5 categories, or 4 if there are NAs in the `shape` variable).
#' * NULL; defaults are used which is the "mixture" set of shapes for non-diverging colour scales (or no colour scale) and "filled+border" for diverging colour scales.
#' @param NAshape Shape to use for NA values in the `shape` variable. Default is shape 7, or shape 25 if filled shapes with a border are being used.
#' @param showSampleNames Logical indicating whether to show the sample names.
#' @param pointSize Numeric value to set the size of the points. Default is 2.
#' @param alpha Numeric value between 0 and 1 to set alpha of points. Default is 1.
#' @param plotlyAnnotations Vector of columns to annotate for plotly, e.g. c("group","tissue")
#' @return A list of ggplot objects: one for each combination of `object@res`, `colour` and `components`.
#'
plotDimRed <- function(object,
                    qseaSet = NULL,
                    components = list(c(1, 2), c(2, 3)),
                    colour = NULL,
                    colourPalette = NULL,
                    NAcolour = "grey50",
                    symDivColourScale = FALSE,
                    shape = NULL,
                    shapePalette = NULL,
                    NAshape = NULL,
                    showSampleNames = FALSE,
                    pointSize = 2,
                    alpha = 1,
                    plotlyAnnotations = ""
){

  if (!inherits(object,"mesaDimRed")) {
    stop("First argument should be the output from the getPCA()/getUMAP() functions in mesa.")
  }

  if (!is.null(qseaSet)) {
    if (!is.qseaSet(qseaSet)) {
      stop("Second argument should be a qseaSet")
    }
    sampleTable <- qseaSet %>% qsea::getSampleTable()
  } else {
    sampleTable <- object@sampleTable
  }

  if (!is.null(colour)){
    colDiff <- setdiff(colour, colnames(sampleTable))
    if(length(colDiff) > 0){
      stop(glue::glue("Can't colour by {colDiff}, as it is not present in the sampleTable!
                      
                      ")) #empty line is required here
    }
  }

  if (!is.null(shape)){
    colDiff <- setdiff(shape, colnames(sampleTable))
    if(length(colDiff) > 0){
      stop(glue::glue("Can't set shapes by {colDiff}, as it is not present in the sampleTable!
                      
                      ")) #empty line is required here
    }
  }
    
  if (!is.list(components)) {
    components <- list(components)
  }

  if (object@params$method == "PCA") {
    columnPrefix <- "PC"
  } else if (object@params$method == "UMAP") {
    columnPrefix <- "UMAP"
  } else {
    stop("Method {object@params$method} not known")
  }

  if (length(plotlyAnnotations) > 1) {
    plotlyAnnotations <- plotlyAnnotations %>% purrr::set_names(., nm = .)
  } else if (plotlyAnnotations != "") {
    plotlyAnnotations <- plotlyAnnotations %>% purrr::set_names(., nm = .)
  }

  components <- components %>% purrr::set_names(purrr::map(components, ~ glue::glue("{columnPrefix}{.x}") %>% glue::glue_collapse("vs")))

  ggp <- purrr::imap(object@res, function(single, resName) {

    numWindows <- length(single@windows)

    if (columnPrefix == "PC") {
      propVar <- single@prcomp$sdev ^ 2 / sum(single@prcomp$sdev ^ 2)
      propVar <- round(propVar * 100, 2)
      plotData <- single@prcomp$x
    } else {
      propVar = NULL
      plotData <- single@points
    }

    plotData <- plotData %>%
      tibble::as_tibble(rownames = "sample_name") %>%
      dplyr::left_join(sampleTable, by = "sample_name")

    if (!is.null(colourPalette) & is.null(colour)) {
      stop("`colourPalette` argument is non-NULL, but `colour` argument is NULL.")
    }

    if (!is.null(shapePalette) & is.null(shape)) {
      stop("`shapePalette` argument is non-NULL, but `shape` argument is NULL.")
    }

    if (!is.null(shape) & length(shape) > 1) {
      stop("Argument `shape` can only be of length one.")
    }

    if (is.null(shape)) {
      plotData <- plotData %>%
        dplyr::mutate(NULLshape = 16)

      shape <- "NULLshape"
    }

    if (is.null(colour)) {
      plotData <- plotData %>%
        dplyr::mutate(NULLcol = "black")

      colour <- "NULLcol"
    }

    makePlot <- function(components, plotData, numWindows, my_geom_point, my_scale_colour, my_scale_shape) {

      env <- new.env(parent = globalenv())
      env$plotData <- plotData
      env$columnPrefix <- columnPrefix
      env$components <- components
      env$plotlyAnnotations <- plotlyAnnotations

      topVarInfo <- object@params$topVar %>% filter(resName == !!resName)

      if (is.na(topVarInfo$topVarNum)) {
        titleString <- glue::glue("all {numWindows} windows")
        subtitleString <- glue::glue("Using {object@params$normMethod} values.")
      } else {
        titleString <- glue::glue("top {numWindows} most variable windows")
        if (length(topVarInfo$topVarSamples[[1]]) == length(object@samples)) {
          titleSubstring <- "all "
        } else {
          titleSubstring <- ""
        }
        subtitleString <- glue::glue("Using {object@params$normMethod} values and {titleSubstring}{length(topVarInfo$topVarSamples[[1]])} samples to calculate std dev.")
      }

      ggp <- with(env, {
        ggplot2::ggplot(plotData,
                        ggplot2::aes(!!rlang::sym(glue::glue("{columnPrefix}{components[1]}")),
                                     !!rlang::sym(glue::glue("{columnPrefix}{components[2]}")),
                                     label = sample_name,
                                     !!!rlang::syms(plotlyAnnotations)
                        ))
      }) +
        my_geom_point +
        my_scale_colour +
        my_scale_shape +
        ggplot2::ggtitle(glue::glue("{object@params$method} for {length(object@samples)} samples using {titleString}."),
                         subtitle = subtitleString) +
        ggplot2::theme_bw() +
        ggplot2::theme(plot.title = ggplot2::element_text(size = 12.5))

      if (object@params$method == "PCA") {
        ggp <- ggp +
          ggplot2::xlab(glue::glue("PC{components[1]} ({propVar[components[1]]}%)")) +
          ggplot2::ylab(glue::glue("PC{components[2]} ({propVar[components[2]]}%)"))
      }

      if (showSampleNames) {
        if (!requireNamespace("ggrepel", quietly = TRUE)) {
          message("Package \"ggrepel\" is recommended to repel labels. Using default method.")
          ggp <- ggp + ggplot2::geom_text()
        } else {
          ggp <- ggp + ggrepel::geom_text_repel()
        }
      }

      return(ggp)
    }

    if (length(colour) == 1 && colour == "NULLcol") {

      my_scale_shape <- getShapeScale(plotData, shape, shapePalette, colourScaleType = NULL, NAshape = NAshape)

      my_geom_point <- getGeomPoint(colour, shape, my_scale_shape, pointSize = pointSize, alpha = alpha)

      my_scale_colour <- ggplot2::scale_colour_identity()

      ggp <- purrr::map(components, makePlot, plotData, numWindows, my_geom_point, my_scale_colour, my_scale_shape)

      return(ggp)

    } else {

      ggp <- purrr::map2(purrr::set_names(colour), list(colourPalette), function(cV, cols) {

        cVdat <- plotData[[cV]]

        colourScaleType <- dplyr::case_when(is.factor(cVdat) || is.character(cVdat) ~ "qualitative", # qualitative variable
                                            is.numeric(cVdat) && min(cVdat, na.rm = TRUE) >= 0 ~ "sequential_non_neg", # non-negative sequential variable
                                            is.numeric(cVdat) && max(cVdat, na.rm = TRUE) <= 0 ~ "sequential_non_pos", # non-positive sequential variable
                                            is.numeric(cVdat) && (max(cVdat, na.rm = TRUE) > 0 && min(cVdat, na.rm = TRUE) < 0) ~ "diverging") # diverging variable

        if (is.na(colourScaleType)) {
          stop(glue::glue("The variable `{cV}` can not be mapped to a colour scale."))
        }

        my_scale_shape <- getShapeScale(plotData, shape, shapePalette, colourScaleType)

        my_geom_point <- getGeomPoint(cV, shape, my_scale_shape, pointSize = pointSize, alpha = alpha)

        my_scale_colour <- getColourScale(plotData, cV, cols, colourScaleType, my_scale_shape, NAcolour = NAcolour, symDivColourScale = symDivColourScale)

        ggp <- purrr::map(components, makePlot, plotData, numWindows, my_geom_point, my_scale_colour, my_scale_shape)

        return(ggp)

      })
    }
  })

  return(ggp)
}
