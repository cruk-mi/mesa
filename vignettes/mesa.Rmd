---
title: "Introduction to mesa Package"
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    fig_width: 5
vignette: >
  %\VignetteIndexEntry{Analyzing Methylation Enrichment Sequencing data with mesa}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
---

```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(tidy = FALSE,
                      cache = FALSE,
                      dev = "png",
                      message = FALSE, error = FALSE, warning = TRUE)

```	

# Introduction

This vignette is designed to introduction the `mesa` package, showing off the basic functionality. 
The `mesa` package is a package to analyse methylation enrichment sequencing data. 
This is generated by performing next-generation sequencing (NGS) on DNA which has been enriched for those fragments of DNA which contain methylation on the cytosine of CG dinucleotides. This may be via immunoprecipitation (MeDIP-seq), or via a pulldown performed with a protein in the methyl-binding-domain (MBD) family (MBD-seq); either method is sufficient. 
Once this enrichment step has performed, the enriched set of DNA fragments is then sequenced on a high-throughput sequencer to produce FASTQ files. These should be aligned to a reference genome and de-duplicated (this MUST be done, to prevent PCR-duplicates from looking like a peak) to produce bam files using standard alignment techniques. For details on how to generate the qseaSet from bam files, see this vignette (XXX).
If the enrichment step has worked correctly, there should be peaks of reads present at regions of the genome where the DNA contained methylated CGs, with minimal background reads where there is not.

# Example
For the examples here, we will use an example dataset consisting of 10 samples; 5 tumours and 5 matched adjacent normal samples. For size reasons, this is only includes a small part of chromosome 7.

First we will load some useful packages (parts of the `tidyverse`), and shorten the name of the example dataset to just be `qseaSet`, and see what it contains. Throughout this vignette we assume familiarity with the tidyverse, and with the pipe operator `%>%`.

```{r}
library(dplyr)
library(stringr)
library(ggplot2)
library(qsea)
qseaSet <- exampleTumourNormal
```

As the underlying structure to hold our methylation data we use the `qsea` package. The tutorial vignette for this package is [available] (https://bioconductor.org/packages/release/bioc/vignettes/qsea/inst/doc/qsea_tutorial.html), but we will cover these concepts here.

The qseaSet object contains a number of different pieces of information regarding the experiment, in one single object. If we evaluate it, we see some summary information. This includes the number of samples included, their names and how many windows are present.

```{r}
qseaSet
```

# Parts of a qseaSet
The qseaSet contains multiple parts to it. The main ones to be aware of are:
* Sample table
* Counts matrix
* Windows
* Copy number variation (CNV) matrix
* Library information

We will go into some detail about each of these components here.

## Sample Table

The sample table is the sample metadata (meaning the data about the data). This is a data frame with one row for each sample in your qseaSet. It *MUST* contain a column called `sample_name`, the primary identifier used in `qsea`, as well as a `group` column which indicates replicate information to collapse replicates (if present) for certain functions. Any other columns can then be added onto this table, and it should contain any metadata to describe the different samples contained within the qseaSet.

We access the sample table using the function `getSampleTable`:

```{r}
qseaSet %>% getSampleTable()
```

We can also get a vector of the samples present inside the qseaSet by using `getSampleNames`:

```{r}
qseaSet %>% getSampleNames()
```

As the sample table is so important, mesa extends a number of `dplyr` (tidyverse) functions that let you modify it. For instance, if we want to add a new column to the sample table, we can use `mutate`:

```{r}
qseaSet %>%
  mutate(new_column = "New") %>%
  getSampleTable()
```

Sometimes you have further information about some or all samples that you want to include, at which point you can use `left_join` to combine with a new data frame. Missing data is fine, and you can join on a different column by using `by`.

```{r}
tumourVAFdata <- tribble(~sample_name, ~VAF, #VAF = Variant Allele Frequency
                         "Colon1_T",23,
                         "Colon2_T",40,
                         "Lung1_T",15,
                         "Lung3_T",5)

qseaSet %>%
  left_join(tumourVAFdata) %>%
  getSampleTable() %>%
  dplyr::select(sample_name, VAF)

```

We can filter the samples present in the qseaSet by using the `filter` function. This takes the sample table, filters using the logical criteria given, and returns a qseaSet with (potentially) fewer samples. All the subcomponents of the qseaSet are reduced in this way behind the scenes.

```{r}
qseaSet %>%
  filter(tumour == "Tumour")
```

There are also functions for sorting the names of the qseaSet `sort` and `arrange`,

```{r}
qseaSet %>%
  arrange(tumour)
```

We can also remove columns of the sample table via the `select` function from `dplyr`, but this currently should only be used for dropping columns:

```{r}
qseaSet %>%
  dplyr::select(-tumour) %>%
  getSampleTable()
```

Note as usual in R, all of these functions won't change the base object, and need to be assigned to a new variable (or the same variable, for functions like `mutate`). 

## Counts matrix

The counts matrix holds how many fragments of DNA (which may be a single read or a paired read) were assigned to each window when the qsea object was built. Note that qsea uses the *centre* of the fragment to assign the window. This counts matrix should not generally be used directly (we will cover how to make tables of data later), but you can access via:

```{r}
qseaSet %>%
  getCounts() %>%
  head()
```

Note that this object does not have any information as to where each window is located. That information is all kept inside the regions slot (see below).

## Windows
The regions object is a GenomicRanges (GRanges) object, representing the genomic windows that the qseaSet covers. This is similar to a data frame, but with additional information attached to it. In this the chromosomes are represented by the `seqnames` column, and the start-stop positions are part of the `ranges` column. We would highly recommend the use of the `plyranges` package to work with GRanges objects.

For DNA methylation this also contains a column called `CpG_density`, which is a normalised value representing how many CG dinucleotides were present in the reference genome for that window. For methylation enrichment sequencing, regions with more methylated CG dinucleotides are more likely to be successfully pulled down, so windows with a low CpG_density are unlikely to be captured.

```{r}
qseaSet %>%
  getWindows()
```

We can filter the regions of the qseaSet by using the `filterWindows` function. Again, this uses `dplyr::filter` to do the logical subsetting. This function can also use the `seqnames` (i.e. chromosome), `start` or `end` columns to filter on.

```{r}
qseaSet %>%
  filterWindows(CpG_density >= 10)

qseaSet %>%
  filterWindows(start >= 26000000)
```

We can also use an already existing GRanges object (or a data frame that has the columns `seqnames`, `start` and `end`) to take the intersection with by using `filterByOverlaps` (this calls the `plyranges` function `filter_by_overlaps`):

```{r}
regionOfInterest <- tibble(seqnames = 7, start = 25000000, end = 26000000)

qseaSet %>%
  filterByOverlaps(regionOfInterest)
```

There also exists a `filterByNonOverlaps` function, which will keep regions which do not overlap with the function.

### Copy Number Variation
The qseaSet object can also contain information on the copy number variation (CNV) that has been calculated for each sample. This is where the number of copies of each chromosome, or parts of the chromosome, are varying, for instance during cancerigenesis. For known variation of entire chromosomes, e.g. sex chromosomes, the zygosity option can be set, as detailed in the `qsea` documentation.

This is often characterised via (shallow) sequencing of the DNA without performing the enrichment step, and is stored as a GRanges object, accessed via the function `getCNV`. 
`mesa` contains routines to add this from bam files in the generation step using the package `hmmcopy`.

```{r}
qseaSet %>%
  getCNV()
```

### Library Information
The qseaSet also keeps information about samples in a slot called libraries. This includes the number of fragments in each sample for instance. When we generate qseaSets via the pipeline, this includes a set of columns related to metrics such as the number of reads/pairs/fragments at different stages of the process. We can use the `addLibraryInformation` function to move these onto the sampleTable, in order to be able to see or filter on them.

```{r}
qseaSet %>%
  addLibraryInformation() %>%
  getSampleTable() %>%
  as_tibble() %>%
  dplyr::select(sample_name, total_fragments, valid_fragments, relH)
```

From the CBC pipeline, these columns include the following information:
* *qsea_initial_reads*: The number of reads (not pairs) in the bam file that was read by qsea
* *qsea_initial_pairs*: The number of (properly) paired reads in the bam file that was read by qsea
* *qsea_initial_r1s*: The number of R1s without a suitable in the bam file that was read by qsea
* *qsea_mapq_filtered_pairs*: The number of pairs remaining after mapping quality filtering (MAPQ)
* *qsea_size_filtered_pairs*: The number of pairs remaining after size filtering
* *qsea_filtered_r1s*: The number of R1s remaining after MAP filtering
* *total_fragments*: The total number of fragments that were remaining after the above filtering steps
* *valid_fragments*: The total number of fragments remaining after filtering out the blacklist regions. A key metric.
* *library_factor*: A qsea calculated value related to the distribution of the reads over the genome
* *offset*: A qsea calculated value related to the enrichment of the data, with how many of the reads are in regions with low CpG density
* *fragment_median*: The median of the fragment size distribution
* *fragment_mean*: The mean of the fragment size distribution
* *fragment_sd*: The standard deviation of the fragment size distribution
* *relH*: The relative enrichment of the pieces of genome covered by the fragments, based on (#CGs in fragments)/(#CGs in genome)
* *GoGe*: Another enrichment measurement, based on (normalised) #CGs/(#Cs * #Gs) inside the fragments.
* *fragments_without_pattern*: Number of fragments without a CG in the reference genome
* *prop_without_pattern*: Proportion of fragments without a CG in the reference genome
* *initial_reads*: Number of initial FASTQ reads (not pairs)
* *mapped_reads*: Number of mapped FASTQ reads (not pairs)
* *properly_paired_reads*: Number of properly paired read pairs
* *contamination_filtered_reads*: Number of mapped reads after filtering for mouse reads (if applicable). If not filtered, should be the same as mapped_reads.
* *dedup_reads*: Number of reads after deduplication step
* *prop_final*: Proportion of reads remaining after deduplication step, compared with the initial reads.

For each of these columns, an equivalent column is also added starting with `input_`, corresponding to the non-enriched "Input" sample used for estimation of copy number variation.

As there are so many columns here, we don't add them by default onto the sampleTable for conciseness, hence the need to use the `addLibraryInformation` function:

```{r}
qseaSet %>%
  addLibraryInformation() %>%
  getSampleTable() %>%
  as_tibble() %>%
  dplyr::select(sample_name, total_fragments, valid_fragments, relH)
```

### Parameters, Enrichment, Zygosity
There are also three other slots of the qseaSet, where it stores internal information. These should not need to be modified or accessed in the normal course of use so won't be covered here.

