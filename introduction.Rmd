---
title: "Introduction to mesa Package"
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    fig_width: 5
vignette: >
  %\VignetteIndexEntry{Analyzing Methylation Enrichment Sequencing data with mesa}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
---

```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(tidy = FALSE,
                      cache = FALSE,
                      dev = "png",
                      message = FALSE, error = FALSE, warning = TRUE)

```	

# Introduction

This vignette is designed to introduction the `mesa` package, showing off the basic functionality. 
The `mesa` package is a package to analyse methylation enrichment sequencing data. 
This is generated by performing next-generation sequencing (NGS) on DNA which has been enriched for those fragments of DNA which contain methylation on the cytosine of CG dinucleotides. This may be via immunoprecipitation (MeDIP-seq), or via a pulldown performed with a protein in the methyl-binding-domain (MBD) family (MBD-seq); either method is sufficient. 
Once this enrichment step has performed, the enriched set of DNA fragments is then sequenced on a high-throughput sequencer to produce FASTQ files. These should be aligned to a reference genome and de-duplicated (this MUST be done, to prevent PCR-duplicates from looking like a peak) to produce bam files using standard alignment techniques. For details on how to generate the qseaSet from bam files, see this vignette (XXX).
If the enrichment step has worked correctly, there should be peaks of reads present at regions of the genome where the DNA contained methylated CGs, with minimal background reads where there is not.

# Example
For the examples here, we will use an example dataset consisting of 10 samples; 5 tumours and 5 matched adjacent normal samples. For size reasons, this is only includes a small part of chromosome 7.

First we will load some useful packages (parts of the `tidyverse`), and shorten the name of the example dataset to just be `qseaSet`, and see what it contains. Throughout this vignette we assume familiarity with the tidyverse, and with the pipe operator `%>%`.

```{r}
library(dplyr)
library(stringr)
library(ggplot2)
library(qsea)
library(mesa)
qseaSet <- exampleTumourNormal
```

As the underlying structure to hold our methylation data we use the `qsea` package. The tutorial vignette for this package is [available] (https://bioconductor.org/packages/release/bioc/vignettes/qsea/inst/doc/qsea_tutorial.html), but we will cover these concepts here.

The qseaSet object contains a number of different pieces of information regarding the experiment, in one single object. If we evaluate it, we see some summary information. This includes the number of samples included, their names and how many windows are present.

```{r}
qseaSet
```

# Parts of a qseaSet
The qseaSet contains multiple parts to it. The main ones to be aware of are:
* Sample table
* Counts matrix
* Windows
* Copy number variation (CNV) matrix
* Library information

We will go into some detail about each of these components here.

## Sample Table

The sample table is the sample metadata (meaning the data about the data). This is a data frame with one row for each sample in your qseaSet. It *MUST* contain a column called `sample_name`, the primary identifier used in `qsea`, as well as a `group` column which indicates replicate information to collapse replicates (if present) for certain functions. Any other columns can then be added onto this table, and it should contain any metadata to describe the different samples contained within the qseaSet.

We access the sample table using the function `getSampleTable`:

```{r}
qseaSet %>% getSampleTable()
```

We can also get a vector of the samples present inside the qseaSet by using `getSampleNames`:

```{r}
qseaSet %>% getSampleNames()
```

As the sample table is so important, mesa extends a number of `dplyr` (tidyverse) functions that let you modify it. For instance, if we want to add a new column to the sample table, we can use `mutate`:

```{r}
qseaSet %>%
  mutate(new_column = "New") %>%
  getSampleTable()
```

Sometimes you have further information about some or all samples that you want to include, at which point you can use `left_join` to combine with a new data frame. Missing data is fine, and you can join on a different column by using `by`.

```{r}
tumourVAFdata <- tribble(~sample_name, ~VAF, #VAF = Variant Allele Frequency
                         "Colon1_T",23,
                         "Colon2_T",40,
                         "Lung1_T",15,
                         "Lung3_T",5)

qseaSet %>%
  left_join(tumourVAFdata) %>%
  getSampleTable() %>%
  dplyr::select(sample_name, VAF)

```

We can filter the samples present in the qseaSet by using the `filter` function. This takes the sample table, filters using the logical criteria given, and returns a qseaSet with (potentially) fewer samples. All the subcomponents of the qseaSet are reduced in this way behind the scenes.

```{r}
qseaSet %>%
  filter(tumour == "Tumour")
```

There are also functions for sorting the names of the qseaSet `sort` and `arrange`,

```{r}
qseaSet %>%
  arrange(tumour)
```

We can also remove columns of the sample table via the `select` function from `dplyr`, but this currently should only be used for dropping columns:

```{r}
qseaSet %>%
  dplyr::select(-tumour) %>%
  getSampleTable()
```

Note as usual in R, all of these functions won't change the base object, and need to be assigned to a new variable (or the same variable, for functions like `mutate`). 

## Counts matrix

The counts matrix holds how many fragments of DNA (which may be a single read or a paired read) were assigned to each window when the qsea object was built. Note that qsea uses the *centre* of the fragment to assign the window. This counts matrix should not generally be used directly (we will cover how to make tables of data later), but you can access via:

```{r}
qseaSet %>%
  getCounts() %>%
  head()
```

Note that this object does not have any information as to where each window is located. That information is all kept inside the regions slot (see below).

## Windows
The regions object is a GenomicRanges (GRanges) object, representing the genomic windows that the qseaSet covers. This is similar to a data frame, but with additional information attached to it. In this the chromosomes are represented by the `seqnames` column, and the start-stop positions are part of the `ranges` column. We would highly recommend the use of the `plyranges` package to work with GRanges objects.

For DNA methylation this also contains a column called `CpG_density`, which is a normalised value representing how many CG dinucleotides were present in the reference genome for that window. For methylation enrichment sequencing, regions with more methylated CG dinucleotides are more likely to be successfully pulled down, so windows with a low CpG_density are unlikely to be captured.

```{r}
qseaSet %>%
  getWindows()
```

We can filter the regions of the qseaSet by using the `filterWindows` function. Again, this uses `dplyr::filter` to do the logical subsetting. This function can also use the `seqnames` (i.e. chromosome), `start` or `end` columns to filter on.

```{r}
qseaSet %>%
  filterWindows(CpG_density >= 10)

qseaSet %>%
  filterWindows(start >= 26000000)
```

We can also use an already existing GRanges object (or a data frame that has the columns `seqnames`, `start` and `end`) to take the intersection with by using `filterByOverlaps` (this calls the `plyranges` function `filter_by_overlaps`):

```{r}
regionOfInterest <- tibble(seqnames = 7, start = 25000000, end = 26000000)

qseaSet %>%
  filterByOverlaps(regionOfInterest)
```

There also exists a `filterByNonOverlaps` function, which will keep regions which do not overlap with the function.

### Copy Number Variation
The qseaSet object can also contain information on the copy number variation (CNV) that has been calculated for each sample. This is where the number of copies of each chromosome, or parts of the chromosome, are varying, for instance during cancerigenesis. For known variation of entire chromosomes, e.g. sex chromosomes, the zygosity option can be set, as detailed in the `qsea` documentation.

This is often characterised via (shallow) sequencing of the DNA without performing the enrichment step, and is stored as a GRanges object, accessed via the function `getCNV`. 
`mesa` contains routines to add this from bam files in the generation step using the package `hmmcopy`.

```{r}
qseaSet %>%
  getCNV()
```

### Library Information
The qseaSet also keeps information about samples in a slot called libraries. This includes the number of fragments in each sample for instance. When we generate qseaSets via the pipeline, this includes a set of columns related to metrics such as the number of reads/pairs/fragments at different stages of the process. We can use the `addLibraryInformation` function to move these onto the sampleTable, in order to be able to see or filter on them.

```{r}
qseaSet %>%
  addLibraryInformation() %>%
  getSampleTable() %>%
  as_tibble() %>%
  dplyr::select(sample_name, total_fragments, valid_fragments, relH)
```

From the CBC pipeline, these columns include the following information:
* *qsea_initial_reads*: The number of reads (not pairs) in the bam file that was read by qsea
* *qsea_initial_pairs*: The number of (properly) paired reads in the bam file that was read by qsea
* *qsea_initial_r1s*: The number of R1s without a suitable in the bam file that was read by qsea
* *qsea_mapq_filtered_pairs*: The number of pairs remaining after mapping quality filtering (MAPQ)
* *qsea_size_filtered_pairs*: The number of pairs remaining after size filtering
* *qsea_filtered_r1s*: The number of R1s remaining after MAP filtering
* *total_fragments*: The total number of fragments that were remaining after the above filtering steps
* *valid_fragments*: The total number of fragments remaining after filtering out the blacklist regions. A key metric.
* *library_factor*: A qsea calculated value related to the distribution of the reads over the genome
* *offset*: A qsea calculated value related to the enrichment of the data, with how many of the reads are in regions with low CpG density
* *fragment_median*: The median of the fragment size distribution
* *fragment_mean*: The mean of the fragment size distribution
* *fragment_sd*: The standard deviation of the fragment size distribution
* *relH*: The relative enrichment of the pieces of genome covered by the fragments, based on (#CGs in fragments)/(#CGs in genome)
* *GoGe*: Another enrichment measurement, based on (normalised) #CGs/(#Cs * #Gs) inside the fragments.
* *fragments_without_pattern*: Number of fragments without a CG in the reference genome
* *prop_without_pattern*: Proportion of fragments without a CG in the reference genome
* *initial_reads*: Number of initial FASTQ reads (not pairs)
* *mapped_reads*: Number of mapped FASTQ reads (not pairs)
* *properly_paired_reads*: Number of properly paired read pairs
* *contamination_filtered_reads*: Number of mapped reads after filtering for mouse reads (if applicable). If not filtered, should be the same as mapped_reads.
* *dedup_reads*: Number of reads after deduplication step
* *prop_final*: Proportion of reads remaining after deduplication step, compared with the initial reads.

For each of these columns, an equivalent column is also added starting with `input_`, corresponding to the non-enriched "Input" sample used for estimation of copy number variation.

As there are so many columns here, we don't add them by default onto the sampleTable for conciseness, hence the need to use the `addLibraryInformation` function:

```{r}
qseaSet %>%
  addLibraryInformation() %>%
  getSampleTable() %>%
  as_tibble() %>%
  dplyr::select(sample_name, total_fragments, valid_fragments, relH)
```

### Parameters, Enrichment, Zygosity
There are also three other slots of the qseaSet, where it stores internal information. These should not need to be modified or accessed in the normal course of use so won't be covered here.

# Quality Control

# Differentially Methylated Regions
## Introduction
One very important question in analysis of ME-Seq is the calculation of differentially methylated regions. This requires looking over the windows and asking whether there is a change in the amount of methylation between certain conditions.

To calculate these, `mesa` wraps several functions from `qsea` into a single function, called `calculateDMRs`. The mandatory arguments for this are which `variable` to make comparisons on (as a string), and what `contrasts` (comparisons) to perform.
For instance, we can ask which windows are differentially methylated between the different states of the `tumour` column in the sampleTable. The `contrasts` option can be a few string settings, such as `"all"` or `"first"`:

```{r}
qseaSet %>%
  calculateDMRs(variable = "tumour",
                contrasts = "all") 
```

Or we can provide a dataframe containing the contrasts that we wish to perform:

```{r}
DMRs <- qseaSet %>%
  calculateDMRs(variable = "tumour",
                contrasts = tibble(group1 = "Tumour", group2 = "Normal")) 

DMRs
```

The output of this function is a dataframe. Each row corresponds to a window which was considered to be differentially methylated at the False Discovery Rate (FDR) threshold applied to the adjusted p-values. The first four columns include the window information: `seqnames` (chromosome), `start` and `end` of the window and the CpG_density. The next columns are related to the contrasts undertaken, giving the log2 fold change, `Tumour_vs_Normal_log2FC`, the adjusted p-value, `Tumour_vs_Normal_adjPval`, and the difference in average beta values for the samples with each different type, `Tumour_vs_Normal_betaDelta`. This is repeated if multiple contrasts are calculated in one call to `calculateDMRs`. Then there are a block of columns also includes the average beta and nrpm values for the values of the variable under consideration, e.g. `Tumour_nrpm_means`. 

```{r}
qseaSet %>%
  calculateDMRs(variable = "tumour",
                contrasts = tibble(group1 = "Tumour", group2 = "Normal")) %>%
  colnames()
```

We can also get the individual data values for each differentially methylated window, by setting `keepData = TRUE` and/or `keepGroupMeans = TRUE` options inside `calculateDMRs`, but this is often unnecessary (and makes massive objects when there are a lot of contrasts), so they are set off by default. "Group" means are 

```{r}
qseaSet %>%
  calculateDMRs(variable = "tumour",
                contrasts = tibble(group1 = "Tumour", group2 = "Normal"),
                keepData = TRUE,
                keepGroupMeans = FALSE) 

```



We can incorporate a covariate into the DMR generation process, such as which tissue the samples came from:

```{r}
DMRsCovariateTissue <- qseaSet %>%
  calculateDMRs(variable = "tumour",
                covariates = "tissue",
                contrasts = tibble(group1 = "Tumour", group2 = "Normal")) %>%
  as_tibble()

DMRsCovariateTissue
```

We can see that having included the tissue covariate we now have `DMRsCovariateTissue %>% nrow()` DMRs, rather than the `DMRs %>% nrow()` we had before. This is because we are now looking at which regions have changed, taking into account that some samples are from the lung and some are from the colon. We can go further, and incorporate the individual patient levels, as for each patient the baseline value in each window might be different (more than just the tissue type). This will for instance highlight windows that were already high in one patient but are now even higher. This is analogous to using a paired t-test for multiple samples taken from the same individual, and increases statistical power.

```{r}
DMRsCovariatePatient <- qseaSet %>%
  calculateDMRs(variable = "tumour",
                covariates = "patient", 
                contrasts = tibble(sample1 = "Tumour", sample2 = "Normal")) %>%
  as_tibble()

DMRsCovariatePatient
```

Having done this there are now `DMRsCovariatePatient %>% nrow()` DMRs instead of the `DMRsCovariateTissue %>% nrow()` we had before.

```{r}
qseaSet %>%
  calculateDMRs(variable = "tumour",
                covariates = "patient", 
                contrasts = tibble(sample1 = "Tumour", sample2 = "Normal"),
                fdrThres = 0.001)
```

### Annotation

We can then annotate these regions, by using the function `annotateWindows`, annotating each window with its nearest gene, and returning information about this gene. The result is a data frame with all the previous columns, augmented with some columns generated by the `ChIPseeker` package and some custom columns. By default this will assume that the windows are aligned to the GRCh38/hg38 human genome. This may be overridden by giving the `TxDb` and `annoDb` arguments, see the documentation for `ChIPseeker::annotatePeak` for details. 

```{r}
annoDMRs <- DMRs %>%
  annotateWindows()

annoDMRs %>% 
  colnames()
```

The output includes which gene was assigned to that window, with an `ENSEMBL` ID column, a `SYMBOL` column for a name associated with that gene, and a (confusingly named) `GENENAME` column with a long-form expansion of that name. The `distanceToTSS` column gives how far the query window is away from the Transcriptional Start Site of the gene. It is worth noting this can be positive or negative, depending on which strand the gene is on, and that some genes are very large. 

```{r}
annoDMRs %>% 
  dplyr::select(seqnames, start, end, distanceToTSS, ENSEMBL, SYMBOL, GENENAME)
```

The `annotation` column gives a long-form explanation of the annotation for that window, including which exon of which transcript is assigned, while `shortAnno` abbreviates this just e.g. Intron/Exon/Promoter.

```{r}
annoDMRs %>% 
  dplyr::select(start, SYMBOL, shortAnno, annotation)
```

Details of the full location of the gene are provided, including how long the gene is, and which transcript is being used in the annotations.

```{r}
annoDMRs %>% 
  dplyr::select(geneChr, geneStart, geneEnd, geneLength, geneStrand, geneId, transcriptId)
```

Finally, for hg38, the function also returns several columns regarding whether the region lies within a CpG "island" (characterised regions of the genome with high numbers of CGs), as well as the "shores" that are 2000bp each side of the "island", and "shelves" (a further 2000bp around these). It is possible for a region to be in multiple islands/shores/shelves simultaneously, so these columns give how many of these that they overlap.

```{r}
annoDMRs %>%
  dplyr::select(seqnames, start, end, nIslands, nShore, nShelf, inFantom, landscape)
```

This function works on any data frame with the columns `seqnames`, `start` and `end`, or a GRanges object.

### Plotting DMRs

We can use the `plotRegionsHeatmap` function to plot a heatmap of these 15 windows. This takes a qseaSet as the first argument, and either a GRanges object or a data frame with columns `seqnames`, `start` and `end` as the second argument. 

```{r}
qseaSet %>%
  addLibraryInformation() %>% 
  plotRegionsHeatmap(regionsToOverlap = DMRsCovariatePatient)
```

We can add sample annotation bars to the top of the heatmap by using the sampleAnnotation option: 

```{r}
qseaSet %>%
  addLibraryInformation() %>% 
  plotRegionsHeatmap(regionsToOverlap = DMRsCovariatePatient,
                     sampleAnnotation = tumour)
```


The default is to plot this with the beta values, but you can change that via the `normMethod` option, to get normalised reads per million:

```{r}
qseaSet %>%
  addLibraryInformation() %>% 
  plotRegionsHeatmap(regionsToOverlap = DMRsCovariatePatient, normMethod = "nrpm", clusterRows = TRUE, sampleAnnotation = c("group", "valid_fragments"))
```

This `normMethod` option occurs in a number of functions throughout the package, with the typical choices of `counts`, `nrpm` or `beta` (other options exist within `qsea`).

To add an annotation bar on the top, we can pass a `sampleAnnotation` argument This function takes a qseaSet as the first argument, and then any number of columns which occur in the sample table as the other arguments. For instance, to use it to add an annotation bar with `tumour` and `type`:

```{r}
qseaSet %>%
  plotRegionsHeatmap(regionsToOverlap = DMRsCovariatePatient, 
                     sampleAnnotation = c("tumour", "type"))
```

Note that the annotation option allows for tidy evaluation, so we can also specify the columns unquoted:

```{r}
qseaSet %>%
  plotRegionsHeatmap(regionsToOverlap = DMRsCovariatePatient, 
                     sampleAnnotation = c("tumour", "type"))
```

Annotation colours can be chosen, with a rather specific requirement. This is a list, with named elements (for some/all annotation columns), each containing a named vector, names being the levels of the annotation and values being the colours. 
We can specify colours for just one variable (with the second being chosen automatically):

```{r}
qseaSet %>%
  plotRegionsHeatmap(regionsToOverlap = DMRs, 
                     sampleAnnotation = c("tumour", "type"),
                     annotationColors = list(tumour = c("Normal" = "blue", "Tumour" = "firebrick4"))
                     )
```

Or both variables:

```{r}
annotColours <- list(tumour = c("Normal" = "blue", "Tumour" = "firebrick4"),
     type = c("CRC" = "orange","LUAD" = "lightgreen", "LUSC" = "darkgreen", "NormalColon" = "tan", "NormalLung" = "grey"))

qseaSet %>%
  plotRegionsHeatmap(regionsToOverlap = DMRs, 
                     sampleAnnotation = c("tumour", "type"),
                     annotationColors = annotColours
                     )
```

The heatmap also takes a `description` argument, which is added to the top of the plot.

```{r}
qseaSet %>%
  plotRegionsHeatmap(regionsToOverlap = DMRsCovariatePatient, 
                     sampleAnnotation = c("tumour", "type"),
                     annotationColors = list(tumour = c("Normal" = "blue", "Tumour" = "firebrick4")),
                     description = "Tumour/Normal DMRs, adjusting for patient"
                     )
```

Rows can be clustered using the `clusterRows = TRUE` option:

```{r}
qseaSet %>%
  plotRegionsHeatmap(regionsToOverlap = DMRsCovariatePatient, 
                     sampleAnnotation = c("tumour", "type"),
                     annotationColors = list(tumour = c("Normal" = "blue", "Tumour" = "firebrick4")),
                     description = "Tumour/Normal DMRs, adjusting for patient",
                     clusterRows = TRUE,
                     )
```

While the columns can be controlled with `clusterCols`. By default the columns are clustered but the rows not.
The number of clusters to break the column dendogram into can be controlled using `clusterNum` (set to 1 to have no breaks):

```{r}
qseaSet %>%
  plotRegionsHeatmap(regionsToOverlap = DMRsCovariatePatient, 
                     sampleAnnotation = c("tumour", "type"),
                     annotationColors = list(tumour = c("Normal" = "blue", "Tumour" = "firebrick4")),
                     description = "Tumour/Normal DMRs, adjusting for patient",
                     clusterNum = 3
                     )
```

The default clustering method to use for the dendogram is set as `clusterMethod = "ward.D2"`; other options could be used but this is a good default in my opinion.

<!-- ## Combining qseaSets -->
<!-- We can use the `combineQsets`  -->

<!-- ```{r} -->
<!-- qseaSetWithNCC <- qseaSet %>% -->
<!--   combineQsets("/data/cep/Methylation/pipelineOutput/combined/NCC01/qseaSets/NCC01_FantomPlusDense_min50_max1000_w300_q10.rds") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- qseaSetWithNCC %>% -->
<!--   getSampleTable()  -->

<!-- qseaSetWithNCC %>% -->
<!--   mutate(type = ifelse(str_detect(sample_name,"NCC"),"NCC", type)) %>% -->
<!--   getSampleTable() -->

<!-- qseaSetWithNCC %>% -->
<!--   mutate(type = replace_na(type,"NCC")) %>% -->
<!--   getSampleTable() -->
<!-- ``` -->

<!-- ```{r} -->
<!-- contrasts <- tibble(sample1 = c("LUAD","LUSC","CRC"), sample2 = "NCC") -->

<!-- NCCdmrs <- qseaSetWithNCC %>% -->
<!--   mutate(type = ifelse(str_detect(sample_name,"NCC"),"NCC", type)) %>% -->
<!--   calculateDMRs(variable = "type", -->
<!--                 contrasts = contrasts) -->
<!-- ``` -->







